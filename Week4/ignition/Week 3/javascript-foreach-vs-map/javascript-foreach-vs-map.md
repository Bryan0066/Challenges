It's very common that you'll need to iterate over an array of information. We've discussed a few ways to do so in the article about looping, and now it's time to dive deeper into the methods we have available to us.

## Learning Goals

* Implement `forEach()` to **run some code with** each element in an array
* Implement `map()` to return **a new array** of elements
* Recognize when callback functions are present

`forEach()` will do the same iteration as a `for` loop, executing the given block, or **callback function**, for each element in the array. `forEach()` will call that function each time, but will not return anything. Depending on how we set it up, `forEach()` can **change** (or mutate) the given array, and is often used when outputting something to the console, or storing information in a database.

For example, let's say we had an array of numbers, and we wanted to log each of those numbers to our console. This would be a great use case for `forEach()`! We could do this as follows:

```js
const numbers = [1, 2, 3, 4]
numbers.forEach((number) => {
  console.log(number)
})

// 1
// 2
// 3
// 4
```

This is great for simply providing some output related to each element in our array. However, what if we instead wanted to create a **new** array, so that we could use it somewhere else? For example, let's say we instead wanted to create a new array, `doubled`, so that we could iterate over this brand new array elsewhere in our code. This is where we would want to use `map()`.

`map()` will also execute the given block for each element in the array, however, it *does* return something. Using `map()` **returns a _new_ array** of the return values created when that given block was run. `map()` _**transforms**_ the array. Because of this similarity between `forEach()` and `map()`, we **only** want to use `map()` when we're trying to get a *new*, *different* array than what we already have.

We could make our *new* array of doubled numbers as follows, assigning it to our new array name `doubled`:

```js
const numbers = [1, 2, 3, 4]
const doubled = numbers.map((number) => {
  return(number * 2)
})
console.log(doubled)
// [2, 4, 6, 8]
```

### Callbacks

Both `forEach()` and `map()` accept an _anonymous_ `callback` function as their first parameter. **Callback functions** are functions that are passed into other functions as an argument. A callback function is not executed *immediately* - it is "called back" at some specific point inside the receiving function (here, `forEach()` or `map()`).

Let's look at an example of both in action, using an array we've already seen.

```javascript
const airTravelArray = ["ship", "rocket", "satellite", "drone"]

airTravelArray.forEach((transport) => {
  console.log(`${transport}s away!`)
})

// ships away!
// rockets away!
// satellites away!
// drones away!
```

In the first example, we call `forEach()` on the array `airTravelArray` and pass an argument (**transport**) into the anonymous function. You could read it as `"for each transport element in the array that exists, console log that element plus the letter s and the string away!"`

When you run the above code, you'll see those 4 phrases output to the console. The callback function is invoked 4 times: one for every item in `airTravelArray`. Consider the code above and make a prediction about what the array will look like at the end, then run it and see what's returned. Then, clear your console history and run the below:

```javascript
const airTravelArray = [ "ship", "rocket", "satellite", "drone"]

airTravelArray.forEach((transport) => {
  airTravelArray.push(`${transport}s away!`)
})

console.log(airTravelArray)
// [ "ship", "rocket", "satellite", "drone", "ships away!", "rockets away!", "satellites away!", "drones away!"]
```

In both cases, the `forEach()` function iterated over each item in the array, and did something with a modified version of the item we started with: first, by `console.log`'ing it, and then in the second example, adding it into our original array.  

But what if, instead of adding 4 new things to our already existing array, we wanted to keep our original array as-is, and instead have a NEW array with our full statements inside it?

This is where `map()` can come in. Let's take a look at how we might use it below (remember to clear your console history!):

```javascript
const airTravelArray = [ "ship", "rocket", "satellite", "drone"]

const newArray = airTravelArray.map((transport) => {
  return `${transport}s away!`
})
console.log(newArray)
console.log(airTravelArray)

// newArray = ["ships away!", "rockets away!", "satellites away!", "drones away!"]
// airTravelArray = [ "ship", "rocket", "satellite", "drone"]
```

`map()` returned an entirely new array, assigned by us to `newArray`, which contains the results generated by the return value in the callback. We also confirmed that `airTravelArray` remained the same.

Let's look at another example.

```javascript
const airFuelArray = [200, 15, 175, 0]

const newFuelArray = airFuelArray.map((supply) => {
  return supply * 2
})
console.log(newFuelArray)

// newFuelArray = [400, 30, 350, 0]
```

Here, we iterate over each supply in `airFuelArray`, double it, and add that return value to construct the `newFuelArray`, thus transforming the array we started with.

The anonymous callback function does not HAVE to return an altered version of the array elements, as we have so far (either adding to a string or multiplying). We could even use `map()` with boolean values. Here's a clear example of how that looks. Run this in your console and see what's returned.

```JavaScript
const airTravelArray = [ "ship", "rocket", "satellite", "drone"]

const isOverFourChar = airTravelArray.map((element) => {
  return element.length > 4
})

console.log(isOverFourChar)
// [false, true, true, true]
```

Here we can see that we have a new array, `isOverFourChar`, which contains the evaluation of each element in the `airTravelArray`. It asks the question "Is the element in the array over 4 characters long?" so your expected output will be true/false responses.

### Summary

When deciding which to use, `forEach()` or `map()`, consider the use case of each method and whether or not you need a new array to work with. `forEach()` is often used when outputting something to the console, or storing information in a database. `map()` would be the best choice if we're trying to get a *new*, *different* array than what we already have.
